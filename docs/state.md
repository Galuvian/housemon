# State

There's the beginning of a mechanism to share state between the server and all
connected clients. This state consists of a number of objects. The server saves
this state in Redis, for persistence between restarts.

## Shared state

This design is modeled on something I (jcw) built and used in a previous life,
called "Tequila". Basically, state is managed in the server, and replicated to
all connected clients on startup. After that, all changes are automatically
sent out to clients, allowing them to dynamicaly adapt to everything that
happens in the server or in any of the other connected clients.

Since all state is sent out to each client on startup, this sharing mechanism
is not intended for large amounts of data. For that, upload and a server-side
REST api should probably be added. Shared state is for the quick/dynamic stuff.

The way shared state is implemented meshes nicely with NG, because all shared
state is kept in the "MainCtrl" scope, which is inherited by all other scopes,
due to the way NG and JavaScript's prototypal inheritance works.

The key point to keep in mind is that clients can easily read all shared state,
but that they have to call `$scope.hash.store value` after making any changes.
Such changes will "round-trip" to the server before they end up being updated
in (all!) client scopes.

Lots of details to be worked out. For now, it works for 'briqs', 'bobs', and a
few more collections, and also includes some read-only server information.

## Collections

Data is stored as collections of objects, keyed by a unique numeric id, which
is generated by incrementing a entry in the "ids" hash table in Redis. Each
collection is stored as two hashes: one for mapping keys to id's, one to store
the actual object (as JSON).

For example, the "briqs" collection has a "briqs" key in "ids", which is used
as sequence number of the next new briq. The "briqs:ids" hash will map briq
keys to briq id's, and the "briqs" hash will map id's to the actual briq data.

All modifications use a single "store" method, which accepts a collection name
and the object as arguments. There are three cases for the object:

* NEW: if it has no "id" field, a new number is assigned via the "ids" hash
* MOD: normally, the object has an id as well as a key, and will be updated
* DEL: if the "key" field is null, the object will be deleted via its id field

Collections can be created as follows (it does nothing if it already exists):

    state.collection 'jobs'

We can now store a job item in this shared collection called "jobs":

    state.jobs.store { key: 'me', activity: 'doodle', duration: '30m' }

Once stored on the server, an async event will come back to update the client.
This will have the same info, but also a new "id" field (id's start at 1):

    myjob = { key: 'me', activity: 'doodle', duration: '30m', id: 1 }
    
This job item can now also be reached anywhere in the client via its id:

    myjob = state.jobs[1]

To make a change, just change some fields and store the object:

    myjob.duration = '5m'
    myjob.priority = 123
    state.jobs.store myjob
    
To delete an object from the server, clear its key and store it again:

    myjob.key = null
    state.jobs.store myjob

To iterate over all the job objects, use the collection in the client:

    for k,v of state.jobs
      console.log k,'=',v
      
Finding an object by key is also straightforward:

    job = state.jobs.find 'me'

Do not make changes to the state.jobs collection, as this will not be properly
sent out to the server and other clients. You *can* change the object itself,
as long as you always finish by calling "store" on it.
